#!/usr/bin/env python2
# Copyright 2011 Stefan Majewsky <majewsky@gmx.net>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

import re

class CppGenerator(object):
    """ This class provides infrastructure for generating C++ classes as a pair
        of header and source files.
    """
    def __init__(self, className):
        self.__classPath = className.split("::")
        # key: access, value: tuple(declaration, implementation)
        self.__members = {}

    def addDeclaration(self, declaration, access="public"):
        """ Add a line to the class declaration. In method declarations, write
            "::" before the function name, but omit the class name. Examples:
            >>> ig.addDeclaration("Q_PROPERTY(int foo READ foo)")
            >>> ig.addDeclaration("void ::externallyDefinedMethod();")
            >>> ig.addDeclaration("void ::show();", access="public Q_SLOTS")
        """
        if not access in self.__members:
            self.__members[access] = []
        self.__members[access].append((declaration, ""))

    def addMethod(self, declaration, implementation, access="public"):
        """ Add a member function with implementation to the class. In the
            declaration, write "::" before the function name, but omit the
            class name. Example:
            >>> ig.addDeclaration("int m_foo;", access="private")
            >>> ig.addMethod("int ::foo() const;", "return m_foo;")
        """
        if not access in self.__members:
            self.__members[access] = []
        self.__members[access].append((declaration, implementation))

    def writeHeader(self, fileName, mode="inline"):
        """ Write .h file. Recognized modes are:
            * "inline" (default) - Include all implementations in the header.
            * "noinline" - Do not include any implementations in the header.
              A source file needs to be written with writeSource() and compiled
              to make the class complete.
        """

        # open file for writing
        indent = 0
        f = open(fileName, "w")
        def wf(string):
            if string == "":
                f.write("\n")
            else:
                f.write(("    " * indent) + string + "\n")

        # autogen warning and include guard
        wf("// This file was generated by qdbusxmlprocessor.")
        wf("// DO NOT EDIT! All changes made to it will be lost.")
        wf("")
        guardDefine = re.sub("[-/.]", "_", fileName.upper())
        wf("#ifndef " + guardDefine)
        wf("#define " + guardDefine + "\n")

        # begin namespaces, class declaration
        for namespace in self.__classPath[:-1]:
            wf("namespace %s {" % namespace)
            indent += 1
        wf("class %s : public QDBusAbstractInterface {" % self.__classPath[-1])
        indent += 1

        # write out declarations
        for accessLevel in sorted(self.__members.iterkeys()):
            if accessLevel != "":
                indent -= 1
                wf(accessLevel + ":")
                indent += 1
            for decl, impl in self.__members[accessLevel]:
                # declaration -> no class name necessary
                decl = decl.replace(" ::", " ")
                # no inline mode -> do not edit declaration anymore
                if mode == "noinline" or not impl:
                    wf(decl)
                # inlining -> replace ";" by "{" + body + "}"
                else:
                    wf(decl[:-1] + " {")
                    indent += 1
                    if isinstance(impl, list):
                        for implLine in impl:
                            wf(implLine)
                    else:
                        for implLine in impl.split("\n"):
                            wf(implLine)
                    indent -= 1
                    wf("}")

        # end class declaration, namespaces, include guard
        indent -= 1; wf("};")
        for namespace in self.__classPath[:-1]:
            indent -= 1; wf("}")
        wf("\n#endif // include guard")
